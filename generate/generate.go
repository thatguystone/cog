package generate

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"os"
	"os/exec"
	"slices"
	"strings"

	"github.com/thatguystone/cog/assert"
	"golang.org/x/tools/imports"
)

type Buffer struct {
	bytes.Buffer
	dstPath string
}

func New() *Buffer {
	const (
		cmdSuffix = ".cmd.go"
		outSuffix = ".out.go"
	)

	srcPath := os.Getenv("GOFILE")
	if !strings.HasSuffix(srcPath, cmdSuffix) {
		panic(
			fmt.Errorf(
				`generate cmd %q must have a name in the form of "*%s"`,
				srcPath,
				cmdSuffix,
			),
		)
	}

	b := &Buffer{
		dstPath: strings.TrimSuffix(srcPath, cmdSuffix) + outSuffix,
	}

	fmt.Fprintf(b, "// Code generated by `go generate %s`. DO NOT EDIT.\n", srcPath)
	fmt.Fprintf(b, "\n")
	fmt.Fprintf(b, "package %s\n", getPkgName())
	fmt.Fprintf(b, "\n")

	return b
}

func (b *Buffer) WriteFile() {
	out, err := imports.Process(b.dstPath, b.Bytes(), nil)
	assert.Nil(err)

	// Don't touch identical files, just in case it matters
	if equal(b.dstPath, out) {
		return
	}

	err = os.WriteFile(b.dstPath, out, 0o640)
	assert.Nil(err)
}

func getPkgName() string {
	buf := new(bytes.Buffer)

	cmd := exec.Command("go", "list", "-f={{ .Name }}")
	cmd.Stdout = buf
	cmd.Stderr = os.Stderr

	err := cmd.Run()
	assert.Nil(err)

	return strings.TrimSpace(buf.String())
}

func equal(path string, contents []byte) bool {
	f, err := os.Open(path)
	if err != nil {
		if errors.Is(err, fs.ErrNotExist) {
			return false
		}

		panic(err)
	}

	defer f.Close()

	info, err := f.Stat()
	assert.Nil(err)

	if info.Size() != int64(len(contents)) {
		return false
	}

	mode := info.Mode()
	if !mode.IsRegular() {
		return false
	}

	buf := make([]byte, min(len(contents), 1<<16))
	for chunk := range slices.Chunk(contents, len(buf)) {
		buf = buf[:len(chunk)]

		_, err := io.ReadFull(f, buf)
		assert.Nil(err)

		if !bytes.Equal(chunk, buf) {
			return false
		}
	}

	_, err = f.Read(buf)
	assert.Equal(err, io.EOF)

	return true
}
